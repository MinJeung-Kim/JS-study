---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# 2장 타입

## 2.1 타입이란

***

### 1) 자료형으로서의 타입

* 특정 <mark style="background-color:orange;">메모리 값을 효율적으로 저장하기 위해 타입을 지정</mark>해준다.
* 메모리에 숫자 타입 값이 할당되어 있다면 자바스크립트 엔진은 8바이트 단위로 메모리 공간에 저장된 값을 읽어 온다.
* **개발자는 타입을 사용해서 값의 종류를 명시할 수 있고 메모리를 더욱 효율적으로 사용할 수 있다.**
* **7가지 데이터 타입(자료형)**

<table><thead><tr><th width="156"></th><th width="150"></th><th width="249"></th><th></th></tr></thead><tbody><tr><td>undefined</td><td>null</td><td>Boolean</td><td>Object</td></tr><tr><td>String</td><td>Symbol</td><td>Numeric(Number &#x26; BigInt)</td><td></td></tr></tbody></table>

### 2) 집합으로서의 타입

* 타입은 값이 가질 수 있는 유효한 범위의 집합을 말한다.

```javascript
function double(n) {
    return n * 2;
};

double(2); // 4
double("z"); // ⚠️ Error: Argument of type 'string' is not assignable to parameter of type 'number'(2345)
```

* 타입을 제한하면 타입스크립트 컴파일러는 함수를 호출할 때 호환되는 인자로 호출했는지 판단한다.
* string 타입인 'z'는 number에 할당할 수 없기 때문에 에러가 발생한다.

### 3) 정적 타입과 동적 타입

* 타입을 결정하는 시점에 다라 타입을 정적 타입(static type)과 동적 타입(dynamic type)으로 분류할 수 있다.
* **정적 타입** : 모든 변수의 <mark style="background-color:orange;">타입이 컴파일타임에 결정</mark>되어 타입 에러를 발견할 수 있기 때문에 <mark style="background-color:orange;">프로그램의 안정성을 보장</mark>할 수 있다.
* **동적 타입** : 변수 **타입이 런타임에 결정**되기 때문에 개발 과정에서 에러 없이 코딩할 수 있지만 <mark style="background-color:orange;">언제 프로그램에 오류가 발생할지 모르는 불안감</mark>에 휩싸이게 된다.

{% hint style="info" %}
<mark style="color:blue;">**컴파일타임과 런타임**</mark>

* **컴파일 타임**  : 기계(컴퓨터, 엔진)가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점
* **런타임** :  컴파일이후 변환된 파일이 메모리에 적재되어 실행되는 시점.
{% endhint %}

### 4) 강타입과 약타입

* 개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 **컴파일러 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것**을 `암묵적 타입 변환(Implicit coercion/conversion)`이라고 한다.
* **암묵적 타입 변환 여부에 따라** 타입 시스템을 `강타입(strongly type)`과 `약타입(weakly type)`으로 분류.
* <mark style="background-color:orange;">서로 다른 타입을 갖는 값끼리 연산을 시도할경우</mark> 컴파일러 또는 인터프리터에서 **에러가 발생하면** `강타입`의 언어이고 컴파일러 또는 인터프리터 **내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후 값을 도출할 경우** `약타입`이다.

<table><thead><tr><th width="129">타입</th><th width="220">서로 다른 타입끼리 연산</th><th>언어</th></tr></thead><tbody><tr><td><strong>강타입</strong></td><td>에러</td><td>Python, Ruby, TypeScript</td></tr><tr><td><strong>약타입</strong></td><td>타입 변환하여 연산</td><td>C++, Java, JavaScript</td></tr></tbody></table>

### 5) 컴파일 방식

* 사람이 이해할 수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정.
* 서로 다른 수준(고수준(high level) → 저수준(binary))간의 코드 변환을 의미.
* <mark style="background-color:orange;">타입스크립트를 컴파일하면 타입이 제거된 자바스크립트 소스코드만이 남는다.</mark>
* `템플릿 언어(Template Languages)` 또는 `확장(Extensions)언어`로 해석하는 의견도 있다.



## 2.2 타입스크립트의 타입 시스템

***

### 1) 타입 애너테이션 방식

* **타입 애너테이션(type annotation)이란** 변수나 상수 혹은 함수의 인자와 반환 <mark style="background-color:orange;">값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법</mark>.

```typescript
let isDone: boolean = false;
let decimal: number = 6;
let color: string = "blue";
let list: number[] = [1, 2, 3];
let x: [string, number]; // tuple
```

### 2) 명목적 타이핑

* **명목적 타입 시스템(Nominal Reified Type Systems)**라고 부르기도 한다.
* 타입의 이름을 통해 구분하는 타입 시스템.
* 즉, **타입의 이름이 중요**하며, 이름이 같아야만 해당 타입으로 인정된다.
* <mark style="background-color:blue;">장점</mark>
  * **타입의 의도와 사용 목적을 명확하게 표현** 하여 코드의 안정성과 가독성을 높인다.
  * 잘못된 타입을 사용하는 경우를 줄일 수 있다.
* <mark style="background-color:blue;">단점</mark>
  * **코드의 재사용성이 떨어진다**.
* **대표적인 언어**로 `Java`는 class의 <mark style="background-color:orange;">구조가 같더라도, class의 이름이 다르면 다른 타입으로 간주</mark>한다.

```java
// 클래스나 인터페이스의 이름을 기준으로 타입 구분
class ClassA {
    int value;

    ClassA(int value) {
        this.value = value;
    }
}

class ClassB {
    int value;

    ClassB(int value) {
        this.value = value;
    }
}

public class NominalTypingExample {
    public static void main(String[] args) {
        ClassA a = new ClassA(1);
        ClassB b = new ClassB(1);
 
        // 'ClassA' 타입은 'ClassB' 타입으로 직접 할당할 수 없다.
        // 두 클래스가 구조적으로 동일하더라도, 자바의 타입 시스템에서는 이름을 기준으로 타입을 구분하기 때문.
        a = b; // ⚠️ 컴파일 에러 
        b = a; // ⚠️ 컴파일 에러
    }
}

```

### 3) 구조적 타이핑

* <mark style="background-color:orange;">구조로 타입을 구분</mark>하는 **구조적 타입 시스템(Structural type system)**이다.
* 타입의 이름이 아니라, 타입이 어떤 구조를 가지고 있는지가 중요하다.
* <mark style="background-color:blue;">장점</mark>
  * 구조가 같다면 서로 다른 타입간에도 호환될 수 있기 때문에, 코드를 **재사용 가능**하게 만들 수 있다.
* <mark style="background-color:blue;">단점</mark>
  * **의도치 않은 타입 호환성**으로 인해 예상치 못한 버그가 발생할 수도 있다.
* **대표적인 언어**로 `TypeScript`가 있다.

```typescript
interface InterfaceA {
    value: number;
}

class ClassB {
    value: number;

    constructor(value: number) {
        this.value = value;
    }
}

let a: InterfaceA = { value: 10 }; // InterfaceA 구조를 가진 객체
let b: ClassB = new ClassB(20); // ClassB 인스턴스

// ClassB가 InterfaceA의 구조(value 속성)를 만족하기 때문에, 
// 'InterfaceA' 타입의 변수에 'ClassB' 인스턴스를 할당 가능.
a = b; // 🆗

// 구조가 호환되면 다른 타입의 객체를 할당할 수 있다.
b = { value: 30 }; // 🆗, 'ClassB'의 생성자와 메서드를 제외한 구조적 타이핑에 의해 가능
```

### 4) 구조적 서브타이핑

* **구조적 서브타이핑(Structural Subtyping)**은 구조적 타이핑의 한 형태다.
* 타입 시스템에서 <mark style="background-color:orange;">한 타입이 다른 타입의 서브타입(subtype)인지를 결정할 때, 타입의 구조(속성, 메서드 등)를 기반으로 판단하는 방식</mark>이다.
* 명확하게 타입 간의 관계를 정의하지 않고도, 타입의 구조만으로 상속 관계나 서브타이핑을 자연스럽게 모델링할 수 있다.
* 이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.

#### 4-1) `interface`에서의 구조적 서브타이핑

* `Employee` 인터페이스가 `Person` 인터페이스를 `extends` 키워드를 사용하여 확장하는 경우, `Employee`는 `Person`의 속성을 "상속받았다"고 표현할 수 있다.
* 구조적 상속 또는 타입 상속
* `Person` 타입이 요구되는 모든 곳에서 `Employee` 타입의 객체를 사용할 수 있다.
* `Employee`가 `Person`의 모든 속성을 포함하므로, 구조적으로 `Person`의 서브타입으로 간주된다.

```typescript
interface Person {
    name: string;
    age: number;
}

// Employee 인터페이스는 Person을 확장(extends)하여 employeeId 속성을 추가로 가진다. 
// 따라서 Employee 타입의 객체는 Person 타입의 요구사항을 모두 충족시키며, 
// 추가적인 속성(employeeId)를 가지고 있다.
interface Employee extends Person {
    employeeId: number;
}

// 'greet' 함수는 'Person' 타입의 객체를 매개변수로 받는다.
function greet(person: Person) {
    console.log(`Hello, ${person.name}!`);
}


// Employee 타입의 객체인 employee는 Person의 모든 구조적 특성을 가지고 있기 때문에, 
// greet 함수의 인자로 사용될 수 있다. 
let employee: Employee = {
    name: "John",
    age: 30,
    employeeId: 1234
};

// 'Employee'는 'Person'의 서브타입이다. 
greet(employee); // 🆗 "Hello, John!"
```

* **Employee가 Person의 서브타입이 될 수 있을까?**
  * Employee는  Person의  서브타입이 된다. ⭕
  * TypeScript에서는 인터페이스가 다른 인터페이스를 확장할 때, **확장하는 인터페이스(Employee)가 기본 인터페이스(Person)의 모든 속성을 상속받게 된다.**
  * 확장하는 인터페이스에 추가적인 속성이나 메서드를 선언할 수 있다.
  * 인터페이스를 사용할 때 <mark style="background-color:orange;">**extends**</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">키워드는 확실히 서브타입 관계를 명시적으로 선언</mark>하는 데 중요한 역할을 한다.

```typescript
interface Person {
    employeeId: number;
}

interface Employee extends Person {
    name: string;
    age: number;
}
```

#### 4-2) `type`에서의 구조적 서브타이핑

<div align="left">

<figure><img src="../../.gitbook/assets/2024-02-16 17 38 45.png" alt="" width="354"><figcaption></figcaption></figure>

</div>

* 타입의 호환성이 속성의 구조에 의해 결정된다.&#x20;
* 추가적인 속성(`age` in `B`)이 있더라도, `A` 타입의 요구 사항을 충족시키기 때문에 `B` 타입의 객체를 `A` 타입의 변수에 할당할 수 있다.

<pre class="language-typescript"><code class="lang-typescript">// B 타입은 A 타입의 서브타입이다.
<strong>// B 타입은 A 타입이 가지고 있는 모든 속성(name)을 포함하며, 
</strong><strong>// 추가적으로 age 속성을 더 가지고 있다.
</strong>type A = { name: string };
type B = { name: string, age: number };

let a: A = { name: "John" };
let b: B = { name: "Alice", age: 25 };

// B 타입의 객체가 A 타입의 요구 사항을 만족시키므로, B는 A의 서브타입이다.
a = b; 
</code></pre>

* **그렇다면, A 타입은 B 타입의 서브타입이 될 수 있을까?**
  * `A` 타입이 `B` 타입의 서브타입이 되지 않는다. ❌
  * 구조적 타이핑에서 <mark style="background-color:orange;">서브타입 관계를 판단할 때, 서브타입이 되는 타입은</mark> <mark style="background-color:orange;"></mark><mark style="background-color:orange;">**슈퍼타입**</mark><mark style="background-color:orange;">의 모든 속성과 요구사항을 만족해야한다.</mark>

```typescript
// A 타입의 객체는 B 타입이 요구하는 모든 속성을 가지고 있기 때문에, 
// A 타입은 B 타입의 슈퍼타입이다.
type A = { name: string, age: number };

// B 타입의 객체는 A 타입의 요구사항(name, age)을 충족하지 않기 때문에, 
// B 타입은 A 타입의 서브타입이 될 수 없다.
type B = { name: string };
```

*   **같은 속성을 가지고 있다면 어떤 타입을 슈퍼타입이 될까?**

    <div align="left">

    <figure><img src="../../.gitbook/assets/2024-02-16 17 39 38.png" alt="" width="563"><figcaption></figcaption></figure>

    </div>

    * 타입 `A`와 타입 `B` 사이에는 직접적인 서브타입 관계는 성립하지 않는다.
    * 한 타입이 다른 타입의 위치에 사용될 수 있으려면, 그 타입이 적어도 다른 타입이 요구하는 모든 속성을 포함하고, 해당 속성들이 호환되는 타입을 가져야 함을 의미

```typescript
type A = {
    name: string;
    gender: string;
};

type B = {
    name: string;
    age: number;
}; 
```

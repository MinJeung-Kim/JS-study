---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# 2장 타입

## 2.1 타입이란

***

### 1) 자료형으로서의 타입

* 특정 <mark style="background-color:orange;">메모리 값을 효율적으로 저장하기 위해 타입을 지정</mark>해준다.
* 메모리에 숫자 타입 값이 할당되어 있다면 자바스크립트 엔진은 8바이트 단위로 메모리 공간에 저장된 값을 읽어 온다.
* **개발자는 타입을 사용해서 값의 종류를 명시할 수 있고 메모리를 더욱 효율적으로 사용할 수 있다.**
* **7가지 데이터 타입(자료형)**

<table><thead><tr><th width="156"></th><th width="150"></th><th width="249"></th><th></th></tr></thead><tbody><tr><td>undefined</td><td>null</td><td>Boolean</td><td>Object</td></tr><tr><td>String</td><td>Symbol</td><td>Numeric(Number &#x26; BigInt)</td><td></td></tr></tbody></table>

### 2) 집합으로서의 타입

* 타입은 값이 가질 수 있는 유효한 범위의 집합을 말한다.

```javascript
function double(n) {
    return n * 2;
};

double(2); // 4
double("z"); // ⚠️ Error: Argument of type 'string' is not assignable to parameter of type 'number'(2345)
```

* 타입을 제한하면 타입스크립트 컴파일러는 함수를 호출할 때 호환되는 인자로 호출했는지 판단한다.
* string 타입인 'z'는 number에 할당할 수 없기 때문에 에러가 발생한다.

### 3) 정적 타입과 동적 타입

* 타입을 결정하는 시점에 다라 타입을 정적 타입(static type)과 동적 타입(dynamic type)으로 분류할 수 있다.
* **정적 타입** : 모든 변수의 <mark style="background-color:orange;">타입이 컴파일타임에 결정</mark>되어 타입 에러를 발견할 수 있기 때문에 <mark style="background-color:orange;">프로그램의 안정성을 보장</mark>할 수 있다.
* **동적 타입** : 변수 **타입이 런타임에 결정**되기 때문에 개발 과정에서 에러 없이 코딩할 수 있지만 <mark style="background-color:orange;">언제 프로그램에 오류가 발생할지 모르는 불안감</mark>에 휩싸이게 된다.

{% hint style="info" %}
<mark style="color:blue;">**컴파일타임과 런타임**</mark>

* **컴파일 타임**  : 기계(컴퓨터, 엔진)가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점
* **런타임** :  컴파일이후 변환된 파일이 메모리에 적재되어 실행되는 시점.
{% endhint %}

### 4) 강타입과 약타입

* 개발자가 의도적으로 타입을 명시하거나 바꾸지 않았는데도 **컴파일러 또는 엔진 등에 의해서 런타임에 타입이 자동으로 변경되는 것**을 `암묵적 타입 변환(Implicit coercion/conversion)`이라고 한다.
* **암묵적 타입 변환 여부에 따라** 타입 시스템을 `강타입(strongly type)`과 `약타입(weakly type)`으로 분류.
* <mark style="background-color:orange;">서로 다른 타입을 갖는 값끼리 연산을 시도할경우</mark> 컴파일러 또는 인터프리터에서 **에러가 발생하면** `강타입`의 언어이고 컴파일러 또는 인터프리터 **내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후 값을 도출할 경우** `약타입`이다.

<table><thead><tr><th width="129">타입</th><th width="220">서로 다른 타입끼리 연산</th><th>언어</th></tr></thead><tbody><tr><td><strong>강타입</strong></td><td>에러</td><td>Python, Ruby, TypeScript</td></tr><tr><td><strong>약타입</strong></td><td>타입 변환하여 연산</td><td>C++, Java, JavaScript</td></tr></tbody></table>

### 5) 컴파일 방식

* 사람이 이해할 수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정.
* 서로 다른 수준(고수준(high level) → 저수준(binary))간의 코드 변환을 의미.
* <mark style="background-color:orange;">타입스크립트를 컴파일하면 타입이 제거된 자바스크립트 소스코드만이 남는다.</mark>
* `템플릿 언어(Template Languages)` 또는 `확장(Extensions)언어`로 해석하는 의견도 있다.



## 2.2 타입스크립트의 타입 시스템

***

### 1) 타입 애너테이션 방식

* **타입 애너테이션(type annotation)이란** 변수나 상수 혹은 함수의 인자와 반환 <mark style="background-color:orange;">값에 타입을 명시적으로 선언해서 어떤 타입 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법</mark>.

```typescript
let isDone: boolean = false;
let decimal: number = 6;
let color: string = "blue";
let list: number[] = [1, 2, 3];
let x: [string, number]; // tuple
```

### 2) 구조적 타이핑

* 값이나 객체는 <mark style="background-color:orange;">하나의 구체적인 타입을 가지고 있으며, 타입은 이름으로 구분되고 컴파일타임 이후에도 남아있는데 이것을</mark> **명목적으로 구체화한 타입 시스템(Nominal Reified Type Systems)**라고 부르기도 한다.

```typescript
class Animal {
    String name;
    int age;
}
```

* 서로 다른 클래스끼리 명확한 상속 관계나 공통으로 가지고 있는 인터페이스가 없다면 타입은 서로 호환되지 않는다.

```typescript
interface Developer {
    faceValue: number;
};

interface BankNote {
    faceValue: number;
};

let developer: Developer = { faceValue: 52 };
let bankNote: BankNote = { faceValue: 10000 };

developer = bankNote; // 🆗
bankNote = developer; // 🆗
```

* <mark style="background-color:orange;">타입스크립트는 구조로 타입을 구분</mark>하는 **구조적 타이핑(Structural type system)**이다.

### 3) 구조적 서브타이핑

* 타입스크립트에서는 특정 <mark style="background-color:orange;">값이 strign 또는 number타입을 동시에 가질 수 있는 것</mark>을 **구조적 서브타이핑(Structural Subtyping)**이라고 한다.

```typescript
type stringOrNumber = string | number;
```

* 객체가 가지고 있는 속성(프로퍼티)을 바탕으로 타입을 구분하는 것.
* 이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.

```typescript
interface Pet {
    name: string;
};

interface Cat {
    name: string;
    age: number;
};

let pet: Pet;
let cat: Cat = { name: "Zag", age: 2 };

pet = cat; // 🆗
```
